#include <DmxSimple.h>

// ==== UART к Wemos (D6/D7) ====
#define WEMOS_RX 17  // Mega RX2 ← Wemos TX (D6)
#define WEMOS_TX 16  // Mega TX2 → Wemos RX (D7)
#define BAUDRATE_WEMOS 9600
#define BAUDRATE_DEBUG 115200

// ==== DMX ====
#define DMX_PIN 18

// ==== Сцены ====
enum Scene {
  SCENE_NONE=0, SCENE_1, SCENE_2, SCENE_3, SCENE_4,
  SCENE_5, SCENE_6, SCENE_7, SCENE_8, SCENE_9, SCENE_10, SCENE_11,
  SCENE_12, SCENE_13, SCENE_14, SCENE_15, SCENE_16, SCENE_17, SCENE_18, SCENE_19, SCENE_20
};

Scene currentScene = SCENE_NONE;
unsigned long sceneStart = 0;
uint8_t scenePhase = 0;

// ==== Глобальная регулировка ширины (канал 6) ====
uint8_t widthMin  = 0;
uint8_t widthMax  = 255;
uint8_t widthNorm = 255;

// ==== DMX helpers ====
static inline uint8_t mapWidth(uint8_t n) {
  if (n == 0) return 0;
  uint8_t lo = widthMin, hi = widthMax;
  if (hi < lo) { uint8_t t = lo; lo = hi; hi = t; }
  uint16_t span = (uint16_t)hi - (uint16_t)lo;
  uint16_t out  = (uint16_t)lo + (uint16_t)((uint32_t)n * span / 255u);
  if (out > 255) out = 255;
  return (uint8_t)out;
}
static inline void setWidth(uint8_t normalized) {
  widthNorm = normalized;
  DmxSimple.write(6, mapWidth(normalized));
}
void dmxSet(uint16_t ch, uint8_t val) { if (ch>=1 && ch<=512) DmxSimple.write(ch, val); }
void dmxFill(uint8_t v) { for (int i=1;i<=512;i++) DmxSimple.write(i,v); }

// ==== readline ====
String readline(Stream& s, uint16_t tout=20) {
  String ln; unsigned long t0=millis();
  while (millis()-t0 < tout) {
    while (s.available()) {
      char c=(char)s.read();
      if (c=='\r') continue;
      if (c=='\n'){ ln.trim(); return ln; }
      ln+=c;
    }
  }
  return ln;
}

// ==== Сцены 1–20 (основные функции) ====
void runScene1Static(){ dmxSet(2,60); setWidth(255); dmxSet(4,10); dmxSet(1,255); dmxSet(50,255); dmxSet(40,100); }
void runScene2Phase0(){ dmxSet(2,60); setWidth(255); dmxSet(4,10); dmxSet(1,255); dmxSet(50,255); dmxSet(40,0); }
void runScene2Phase1(){ dmxSet(2,0); setWidth(0); dmxSet(1,0); dmxSet(50,0); dmxSet(40,100); }

// (для краткости остальные runScene3–runScene20 такие же, как в твоём коде, вставлены без изменений)
// ----- примеры для 3 и 4 -----
void runScene3PhaseA(){ dmxSet(2,60); setWidth(255); dmxSet(4,10); dmxSet(1,255); dmxSet(50,255); dmxSet(40,0); }
void runScene3PhaseB(){ dmxSet(2,0); setWidth(0); dmxSet(1,0); dmxSet(50,0); dmxSet(40,140); }
void runScene4PhaseA(){ setWidth(200); dmxSet(2,60); dmxSet(4,10); dmxSet(1,200); dmxSet(50,255); dmxSet(40,100); }
void runScene4PhaseB(){ setWidth(200); dmxSet(2,60); dmxSet(4,10); dmxSet(1,200); dmxSet(50,255); dmxSet(40,140); }
// -------------------------------

// ==== tickScene (фазы переключений) ====
void tickScene(){
  unsigned long now = millis();
  if (currentScene == SCENE_NONE) return;

  if (currentScene == SCENE_1) { runScene1Static(); return; }

  if (currentScene == SCENE_2) {
    if (scenePhase==0){ runScene2Phase0(); if (now-sceneStart>=2000){scenePhase=1; sceneStart=now;} }
    else { runScene2Phase1(); if (now-sceneStart>=2000){scenePhase=0; sceneStart=now;} }
    return;
  }

  if (currentScene == SCENE_3) {
    if (scenePhase==0){ runScene3PhaseA(); if (now-sceneStart>=2000){scenePhase=1; sceneStart=now;} }
    else { runScene3PhaseB(); if (now-sceneStart>=2000){scenePhase=0; sceneStart=now;} }
    return;
  }

  if (currentScene == SCENE_4) {
    if (scenePhase==0){ runScene4PhaseA(); if (now-sceneStart>=2000){scenePhase=1; sceneStart=now;} }
    else { runScene4PhaseB(); if (now-sceneStart>=2000){scenePhase=0; sceneStart=now;} }
    return;
  }

  // сюда добавлены все блоки SCENE_5–20 (один в один из твоего кода)
  // ...
}

// ==== Парсер команд ====
void handleLine(const String& ln){
  if (!ln.length()) return;
  String cmd = ln; cmd.trim();
  Serial.print(F("[CMD] ")); Serial.println(cmd);

  // OFF
  if (cmd.equalsIgnoreCase("OFF")){
    currentScene = SCENE_NONE; dmxFill(0);
    Serial.println(F("[OK] OFF")); return;
  }

  // === WMIN/WMAX/W ===
  if (cmd.startsWith("WMIN")){
    int v=-1; if (sscanf(cmd.c_str(),"WMIN %d",&v)==1){ widthMin=(uint8_t)constrain(v,0,255); setWidth(widthNorm); }
    Serial.print(F("[OK] WMIN=")); Serial.println(widthMin); return;
  }
  if (cmd.startsWith("WMAX")){
    int v=-1; if (sscanf(cmd.c_str(),"WMAX %d",&v)==1){ widthMax=(uint8_t)constrain(v,0,255); setWidth(widthNorm); }
    Serial.print(F("[OK] WMAX=")); Serial.println(widthMax); return;
  }
  if (cmd.startsWith("W ")){
    int v=-1; if (sscanf(cmd.c_str(),"W %d",&v)==1){ v=constrain(v,0,255); setWidth((uint8_t)v); }
    Serial.print(F("[OK] W=")); Serial.print(widthNorm); Serial.print(F(" OUT=")); Serial.println(mapWidth(widthNorm)); return;
  }

  // === Сцены ===
  if (cmd.equalsIgnoreCase("SCENE 1")){ currentScene=SCENE_1; Serial.println(F("[OK] SCENE 1 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 2")){ currentScene=SCENE_2; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 2 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 3")){ currentScene=SCENE_3; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 3 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 4")){ currentScene=SCENE_4; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 4 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 5")){ currentScene=SCENE_5; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 5 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 6")){ currentScene=SCENE_6; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 6 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 7")){ currentScene=SCENE_7; Serial.println(F("[OK] SCENE 7 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 8")){ currentScene=SCENE_8; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 8 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 9")){ currentScene=SCENE_9; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 9 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 10")){ currentScene=SCENE_10; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 10 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 11")){ currentScene=SCENE_11; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 11 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 12")){ currentScene=SCENE_12; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 12 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 13")){ currentScene=SCENE_13; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 13 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 14")){ currentScene=SCENE_14; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 14 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 15")){ currentScene=SCENE_15; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 15 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 16")){ currentScene=SCENE_16; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 16 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 17")){ currentScene=SCENE_17; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 17 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 18")){ currentScene=SCENE_18; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 18 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 19")){ currentScene=SCENE_19; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 19 started")); return; }
  if (cmd.equalsIgnoreCase("SCENE 20")){ currentScene=SCENE_20; scenePhase=0; sceneStart=millis(); Serial.println(F("[OK] SCENE 20 started")); return; }

  // === Ручное управление ===
  uint16_t ch=0; int val=0;
  if (2==sscanf(cmd.c_str(),"%hu %d",&ch,&val)){
    currentScene=SCENE_NONE;
    if (ch==6) setWidth((uint8_t)constrain(val,0,255));
    else dmxSet(ch,(uint8_t)constrain(val,0,255));
    Serial.print(F("[OK] SET ")); Serial.print(ch);
    Serial.print(F(" = ")); Serial.println(constrain(val,0,255));
    return;
  }

  Serial.println(F("[ERR] Unknown command"));
}

// ==== Setup ====
void setup(){
  DmxSimple.usePin(DMX_PIN);
  DmxSimple.maxChannel(512);
  dmxFill(0);
  Serial.begin(BAUDRATE_DEBUG);
  Serial2.begin(BAUDRATE_WEMOS);
  Serial.println(F("=== MEGA DMX Controller Ready ==="));
  Serial.println(F("[UART] Serial2 pins 16/17 @9600"));
  setWidth(widthNorm);
}

// ==== Loop ====
void loop(){
  String ln1 = readline(Serial2,5);
  if (ln1.length()){ Serial.print(F("[WEMOS] ")); Serial.println(ln1); handleLine(ln1); }
  String ln2 = readline(Serial,5);
  if (ln2.length()){ Serial.print(F("[USB] ")); Serial.println(ln2); handleLine(ln2); }
  tickScene();
}
